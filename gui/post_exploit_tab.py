#!/usr/bin/env python3
"""
Post-Exploitation Tab
GUI for post-exploitation functionality
"""

from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
                             QLabel, QLineEdit, QPushButton, QTextEdit,
                             QCheckBox, QGroupBox, QTableWidget, QTableWidgetItem,
                             QHeaderView, QComboBox, QScrollArea)
from PyQt5.QtCore import Qt, QThread, pyqtSignal

# Import core modules
import sys
from pathlib import Path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

class PostExploitTab(QWidget):
    """Post-exploitation tab widget"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        """Initialize the user interface"""
        # Create scroll area for the entire tab
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        # Create main widget
        main_widget = QWidget()
        scroll_area.setWidget(main_widget)
        
        # Create main layout
        main_layout = QVBoxLayout(self)
        main_layout.addWidget(scroll_area)
        
        layout = QVBoxLayout(main_widget)
        
        # Target configuration
        target_group = QGroupBox("Target Configuration")
        target_layout = QGridLayout(target_group)
        
        target_layout.addWidget(QLabel("Target IP:"), 0, 0)
        self.target_input = QLineEdit()
        self.target_input.setPlaceholderText("192.168.1.1")
        target_layout.addWidget(self.target_input, 0, 1)
        
        target_layout.addWidget(QLabel("Credentials:"), 1, 0)
        self.creds_input = QLineEdit()
        self.creds_input.setPlaceholderText("username:password")
        target_layout.addWidget(self.creds_input, 1, 1)
        
        target_layout.addWidget(QLabel("OS Type:"), 2, 0)
        self.os_combo = QComboBox()
        self.os_combo.addItems(["Linux", "Windows", "Auto-detect"])
        target_layout.addWidget(self.os_combo, 2, 1)
        
        layout.addWidget(target_group)
        
        # Post-exploitation options
        options_group = QGroupBox("Post-Exploitation Options")
        options_layout = QVBoxLayout(options_group)
        
        # System enumeration
        self.sys_enum_check = QCheckBox("System Information Enumeration")
        self.sys_enum_check.setChecked(True)
        options_layout.addWidget(self.sys_enum_check)
        
        # Network enumeration
        self.net_enum_check = QCheckBox("Network Information Enumeration")
        self.net_enum_check.setChecked(True)
        options_layout.addWidget(self.net_enum_check)
        
        # User enumeration
        self.user_enum_check = QCheckBox("User Information Enumeration")
        self.user_enum_check.setChecked(True)
        options_layout.addWidget(self.user_enum_check)
        
        # Process enumeration
        self.proc_enum_check = QCheckBox("Process Information Enumeration")
        self.proc_enum_check.setChecked(True)
        options_layout.addWidget(self.proc_enum_check)
        
        # Service enumeration
        self.service_enum_check = QCheckBox("Service Information Enumeration")
        self.service_enum_check.setChecked(True)
        options_layout.addWidget(self.service_enum_check)
        
        # Privilege escalation
        self.privesc_check = QCheckBox("Privilege Escalation Check")
        self.privesc_check.setChecked(True)
        options_layout.addWidget(self.privesc_check)
        
        # Sensitive files
        self.sensitive_files_check = QCheckBox("Sensitive Files Gathering")
        self.sensitive_files_check.setChecked(True)
        options_layout.addWidget(self.sensitive_files_check)
        
        layout.addWidget(options_group)
        
        # Advanced Post-Exploitation Options
        advanced_group = QGroupBox("Advanced Post-Exploitation Options")
        advanced_layout = QVBoxLayout(advanced_group)
        
        # Analysis depth
        depth_layout = QHBoxLayout()
        depth_layout.addWidget(QLabel("Analysis Depth:"))
        self.depth_combo = QComboBox()
        self.depth_combo.addItems(["Quick", "Standard", "Deep", "Comprehensive"])
        self.depth_combo.setCurrentText("Standard")
        depth_layout.addWidget(self.depth_combo)
        depth_layout.addStretch()
        advanced_layout.addLayout(depth_layout)
        
        # Advanced options checkboxes
        self.stealth_check = QCheckBox("Stealth Mode")
        advanced_layout.addWidget(self.stealth_check)
        
        self.priv_esc_check = QCheckBox("Advanced Privilege Escalation")
        self.priv_esc_check.setChecked(True)
        advanced_layout.addWidget(self.priv_esc_check)
        
        self.persistence_check = QCheckBox("Persistence Analysis")
        advanced_layout.addWidget(self.persistence_check)
        
        self.lateral_check = QCheckBox("Lateral Movement")
        advanced_layout.addWidget(self.lateral_check)
        
        self.data_exfil_check = QCheckBox("Data Exfiltration")
        advanced_layout.addWidget(self.data_exfil_check)
        
        self.cred_harvest_check = QCheckBox("Credential Harvesting")
        advanced_layout.addWidget(self.cred_harvest_check)
        
        self.network_disc_check = QCheckBox("Network Discovery")
        advanced_layout.addWidget(self.network_disc_check)
        
        self.service_enum_check = QCheckBox("Service Enumeration")
        advanced_layout.addWidget(self.service_enum_check)
        
        self.registry_check = QCheckBox("Registry Analysis")
        advanced_layout.addWidget(self.registry_check)
        
        self.filesystem_check = QCheckBox("File System Analysis")
        advanced_layout.addWidget(self.filesystem_check)
        
        self.process_check = QCheckBox("Process Analysis")
        advanced_layout.addWidget(self.process_check)
        
        self.memory_check = QCheckBox("Memory Analysis")
        advanced_layout.addWidget(self.memory_check)
        
        self.log_check = QCheckBox("Log Analysis")
        advanced_layout.addWidget(self.log_check)
        
        layout.addWidget(advanced_group)
        
        # Control buttons
        button_layout = QHBoxLayout()
        
        self.start_enum_btn = QPushButton("Start Basic Analysis")
        self.start_enum_btn.clicked.connect(self.start_enumeration)
        button_layout.addWidget(self.start_enum_btn)
        
        self.start_advanced_btn = QPushButton("Start Advanced Analysis")
        self.start_advanced_btn.clicked.connect(self.start_advanced_analysis)
        button_layout.addWidget(self.start_advanced_btn)
        
        self.stop_enum_btn = QPushButton("Stop Analysis")
        self.stop_enum_btn.setEnabled(False)
        self.stop_enum_btn.clicked.connect(self.stop_enumeration)
        button_layout.addWidget(self.stop_enum_btn)
        
        layout.addLayout(button_layout)
        
        # Results section
        results_group = QGroupBox("Post-Exploitation Results")
        results_layout = QVBoxLayout(results_group)
        
        # Results table
        self.results_table = QTableWidget()
        self.results_table.setColumnCount(3)
        self.results_table.setHorizontalHeaderLabels(["Category", "Information", "Details"])
        self.results_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        results_layout.addWidget(self.results_table)
        
        # Results text
        self.results_text = QTextEdit()
        self.results_text.setMaximumHeight(200)
        self.results_text.setPlaceholderText("Post-exploitation results will appear here...")
        results_layout.addWidget(self.results_text)
        
        layout.addWidget(results_group)
        
    def start_enumeration(self):
        """Start post-exploitation enumeration"""
        target = self.target_input.text().strip()
        if not target:
            self.results_text.append("Please enter a target IP")
            return
            
        self.start_enum_btn.setEnabled(False)
        self.stop_enum_btn.setEnabled(True)
        
        # Clear previous results
        self.results_table.setRowCount(0)
        self.results_text.clear()
        
        # Start enumeration in background thread
        self.enum_thread = PostExploitThread(target, self.get_enum_options())
        self.enum_thread.result.connect(self.enum_finished)
        self.enum_thread.start()
        
    def start_advanced_analysis(self):
        """Start advanced post-exploitation analysis"""
        target = self.target_input.text().strip()
        if not target:
            self.results_text.append("Please enter a target IP")
            return
            
        self.start_enum_btn.setEnabled(False)
        self.start_advanced_btn.setEnabled(False)
        self.stop_enum_btn.setEnabled(True)
        
        # Clear previous results
        self.results_table.setRowCount(0)
        self.results_text.clear()
        
        # Start advanced analysis in background thread
        self.enum_thread = AdvancedPostExploitThread(target, self.get_advanced_analysis_options())
        self.enum_thread.result.connect(self.advanced_analysis_finished)
        self.enum_thread.start()
        
    def get_enum_options(self):
        """Get enumeration options"""
        return {
            'system_info': self.sys_enum_check.isChecked(),
            'network_info': self.net_enum_check.isChecked(),
            'user_info': self.user_enum_check.isChecked(),
            'process_info': self.proc_enum_check.isChecked(),
            'service_info': self.service_enum_check.isChecked(),
            'privilege_escalation': self.privesc_check.isChecked(),
            'sensitive_files': self.sensitive_files_check.isChecked(),
            'os_type': self.os_combo.currentText()
        }
        
    def get_advanced_analysis_options(self):
        """Get advanced analysis options"""
        return {
            'analysis_depth': self.depth_combo.currentText().lower(),
            'stealth_mode': self.stealth_check.isChecked(),
            'privilege_escalation': self.priv_esc_check.isChecked(),
            'persistence_analysis': self.persistence_check.isChecked(),
            'lateral_movement': self.lateral_check.isChecked(),
            'data_exfiltration': self.data_exfil_check.isChecked(),
            'credential_harvesting': self.cred_harvest_check.isChecked(),
            'network_discovery': self.network_disc_check.isChecked(),
            'service_enumeration': self.service_enum_check.isChecked(),
            'registry_analysis': self.registry_check.isChecked(),
            'filesystem_analysis': self.filesystem_check.isChecked(),
            'process_analysis': self.process_check.isChecked(),
            'memory_analysis': self.memory_check.isChecked(),
            'log_analysis': self.log_check.isChecked(),
            'system_info': self.sys_enum_check.isChecked(),
            'network_info': self.net_enum_check.isChecked(),
            'user_info': self.user_enum_check.isChecked(),
            'process_info': self.proc_enum_check.isChecked(),
            'service_info': self.service_enum_check.isChecked(),
            'sensitive_files': self.sensitive_files_check.isChecked(),
            'os_type': self.os_combo.currentText()
        }
        
    def enum_finished(self, results):
        """Handle enumeration completion"""
        self.start_enum_btn.setEnabled(True)
        self.start_advanced_btn.setEnabled(True)
        self.stop_enum_btn.setEnabled(False)
        
        # Display results
        for category, info in results.items():
            if isinstance(info, dict):
                for key, value in info.items():
                    row = self.results_table.rowCount()
                    self.results_table.insertRow(row)
                    
                    self.results_table.setItem(row, 0, QTableWidgetItem(category))
                    self.results_table.setItem(row, 1, QTableWidgetItem(key))
                    self.results_table.setItem(row, 2, QTableWidgetItem(str(value)))
                    
                    # Add to results text
                    self.results_text.append(f"{category} - {key}: {value}")
            else:
                row = self.results_table.rowCount()
                self.results_table.insertRow(row)
                
                self.results_table.setItem(row, 0, QTableWidgetItem(category))
                self.results_table.setItem(row, 1, QTableWidgetItem(""))
                self.results_table.setItem(row, 2, QTableWidgetItem(str(info)))
                
                # Add to results text
                self.results_text.append(f"{category}: {info}")
                
    def advanced_analysis_finished(self, results):
        """Handle advanced analysis completion"""
        self.start_enum_btn.setEnabled(True)
        self.start_advanced_btn.setEnabled(True)
        self.stop_enum_btn.setEnabled(False)
        
        # Display advanced results
        if isinstance(results, dict):
            # Display summary
            if 'summary' in results:
                summary = results['summary']
                self.results_text.append(f"Advanced Post-Exploitation Analysis Summary:")
                self.results_text.append(f"Total Categories: {summary.get('total_categories', 0)}")
                self.results_text.append(f"Critical Findings: {summary.get('critical_findings', 0)}")
                self.results_text.append(f"High Risk Items: {summary.get('high_risk_items', 0)}")
                self.results_text.append(f"Risk Score: {summary.get('risk_score', 0)}/10")
                self.results_text.append("")
            
            # Display findings by category
            for category, info in results.items():
                if category != 'summary' and isinstance(info, dict):
                    for key, value in info.items():
                        row = self.results_table.rowCount()
                        self.results_table.insertRow(row)
                        
                        self.results_table.setItem(row, 0, QTableWidgetItem(category))
                        self.results_table.setItem(row, 1, QTableWidgetItem(key))
                        self.results_table.setItem(row, 2, QTableWidgetItem(str(value)))
                        
                        # Add to results text
                        self.results_text.append(f"{category} - {key}: {value}")
                elif category != 'summary':
                    row = self.results_table.rowCount()
                    self.results_table.insertRow(row)
                    
                    self.results_table.setItem(row, 0, QTableWidgetItem(category))
                    self.results_table.setItem(row, 1, QTableWidgetItem(""))
                    self.results_table.setItem(row, 2, QTableWidgetItem(str(info)))
                    
                    # Add to results text
                    self.results_text.append(f"{category}: {info}")
            
            # Display techniques used
            if 'techniques_used' in results:
                self.results_text.append("Advanced Techniques Used:")
                for technique in results['techniques_used']:
                    self.results_text.append(f"  - {technique}")
                self.results_text.append("")
                
        else:
            # Handle non-dict results
            self.results_text.append(f"Advanced Post-Exploitation Analysis Results: {results}")
                
    def stop_enumeration(self):
        """Stop current enumeration"""
        if hasattr(self, 'enum_thread') and self.enum_thread.isRunning():
            self.enum_thread.terminate()
            self.enum_thread.wait()
            
        self.start_enum_btn.setEnabled(True)
        self.start_advanced_btn.setEnabled(True)
        self.stop_enum_btn.setEnabled(False)
        self.results_text.append("Analysis stopped by user")

class PostExploitThread(QThread):
    """Thread for running post-exploitation enumeration"""
    result = pyqtSignal(dict)
    
    def __init__(self, target, options):
        super().__init__()
        self.target = target
        self.options = options
        
    def run(self):
        """Run the post-exploitation enumeration"""
        try:
            try:
                from core.post_exploitation import PostExploitation
            except ImportError:
                self.result.emit({'error': 'PostExploitation module not available'})
                return
                
            post_exploit = PostExploitation()
            
            # Run comprehensive enumeration
            results = post_exploit.comprehensive_enumeration(self.target, self.options)
            
            self.result.emit(results)
            
        except Exception as e:
            self.result.emit({'error': str(e)})

class AdvancedPostExploitThread(QThread):
    """Thread for running advanced post-exploitation analysis"""
    result = pyqtSignal(dict)
    
    def __init__(self, target, options):
        super().__init__()
        self.target = target
        self.options = options
        
    def run(self):
        """Run the advanced post-exploitation analysis"""
        try:
            try:
                from core.post_exploitation import PostExploitation
            except ImportError:
                self.result.emit({'error': 'PostExploitation module not available'})
                return
                
            # Create post-exploitation module with advanced options
            post_exploit = PostExploitation(
                advanced_mode=True,
                stealth_mode=self.options.get('stealth_mode', False)
            )
            
            # Run advanced post-exploitation analysis
            results = post_exploit.advanced_post_exploitation(self.target, self.options)
            
            self.result.emit(results)
            
        except Exception as e:
            self.result.emit({'error': str(e)})
